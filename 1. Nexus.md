# Nexus — Technical Architecture and Governance

**Version**: 3.0  
**Date**: 11.01.2026  
**Status**: Production

---

## Executive Overview

### Vision and Positioning

Nexus is the result of the wish to share my projects and their features that require security to keep them safe. I ended up building a central place for hosting and authenticate my projects.

The platform relies on five main technical components orchestrated via Azure Container Apps and Functions:

- **Next.js 14 Frontend -  Azure Webapp**: Responsive user interface
- **Node.js Authentication Service - ACA**: Centralized identity and session management (NextAuth v5)
- **Nginx Reverse Proxy - ACA**: Single entry point, obfuscated routing, rate limiting
- **Cloudflare Turnstile - Azure function**: Anti-bot protection without user friction (CAPTCHA alternative)
- **Isolated Google OAuth service - Azure function**: Social authentication delegated via dedicated Azure Function

### Guarantees and Compliance

- **Security**: OWASP Top 10 compliance (JWT, XSS, CSRF, SQL/NoSQL injection), AES-256-GCM encryption for OAuth tokens, bcrypt for passwords
- **Availability**: Active health checks (30s interval), retry logic, configured timeouts and logs.
- **GDPR**: Data hosted in Europe (Switzerland North priority), PII log anonymization, Cloudflare Turnstile consent
- **Performance**: HTTP/1.1 Keepalive, pooled connections, short-lived tokens (15 min access, 1 day refresh)

---

## Architecture at a Glance

### System Context View


### OAuth Authentication Flow (Google)

```
1. User clicks "Login with Google"
   │
   ▼
2. Next.js → /api → Nginx → Auth Service
   │ (generates state + PKCE, redirects to OAuth Function)
   ▼
3. OAuth Function (Azure) → Google Authorization Server
   │ (redirect URI to callback Function)
   ▼
4. User consent → Google callback → OAuth Function
   │ (exchanges code for tokens, generates unique sessionId)
   ▼
5. Redirect browser to Next.js with sessionId
   │
   ▼
6. Next.js → /api → Nginx → Auth Service
   │ (exchanges sessionId for refresh + access tokens)
   ▼
7. Auth Service stores refresh token in httpOnly cookie
   │ Access token returned in JSON (localStorage frontend)
   ▼
8. User authenticated, tokens usable for APIs
```

**Guaranteed security properties**:
- Unique CSRF state per OAuth request (stored in DB, 10 min TTL)
- PKCE code_verifier never exposed to frontend
- Access tokens in Authorization Bearer header (sessionStorage)
- Refresh tokens httpOnly, SameSite=Strict (XSS protection)

---

## Core Capabilities

### 1. Multi-Method Authentication

**Benefit**: User flexibility (social login or classic credentials) with uniform security posture.

**Implementation**:
- **Google OAuth**: Delegated to isolated Azure Function (secrets outside auth-service), PKCE + state validation flow
- **Credentials**: Email/password with bcrypt (rounds=10), robust format validation, timing attack protection
- **Dual token system**: Refresh tokens (1d, revocable) + access tokens (15 min, stateless)
- **Active revocation**: MongoDB blacklist with TTL index (automatic expiration), verification at each auth request

**Guarantees**:
- No plaintext passwords (bcrypt + salt)
- No long-lived non-revocable tokens
- Session hijacking limited by short access token duration
- CSRF impossible on state-changing endpoints (double-submit cookie)

### 2. Anti-Bot Protection (Cloudflare Turnstile)

**Benefit**: Malicious traffic filtering without user friction (no visual CAPTCHA).

**Implementation**:
- **Protected entry points**: Credentials login, signup, contact forms
- **Architecture**: 
  1. Frontend integrates Turnstile widget (auto complete challenge)
  2. Turnstile token automatically sent for verification
  3. Azure Function validates token server-side via Cloudflare API
  4. Request rejected if validation fails 
- **Secrets**: Turnstile secret key stored in Key Vault, retrieved via Managed Identity

### 3. Obfuscated Reverse Proxy (Nginx)

**Benefit**: Complete backend topology masking, single point of entry for security and monitoring. The goal is to expose no API endpoints publicly

**Implementation**:
- **Route obfuscation**: Frontend paths (`/api/login`) mapped to nginx location block (`/api/credentials/login`), then real backend endpoints (`/api/auth/login`) - These are demo endpoints. Not the actual ones
- **Rate limiting**: Auth zone (30 req/min), API zone (100 req/min), configurable burst tokens
- **Strict CORS**: Explicit whitelist without regex (ivaninho.pro only)
- **Security headers**: X-Content-Type-Options, X-Frame-Options DENY, X-XSS-Protection, Referrer-Policy
- **Optimizations**: Keepalive (8-12 idle connections/upstream), Connection pooling, timeouts 30-60s

**Guarantees**:
- Impossible to guess backend endpoints from browser DevTools
- Basic DDoS protection via per-IP rate limit (without counting Cloudflare DDoS protection)
- Obfuscated path rotation without frontend impact
- Centralized logging (nginx access/error logs)

### 4. Centralized Secrets Management (Azure Key Vault)

**Benefit**: No plaintext secrets in code/repos, facilitated rotation, complete audit trail.

**Implementation**:
- **Stored secrets**: SECRET_NAME, SECRET_NAME, DB passwords, etc
- **Access**: Managed Identity (Container Apps/Functions), DefaultAzureCredential (dev), ManagedIdentityCredential (prod), strict RBAC (least privilege)
- **Fetch pattern**: Key Vault URI in environment variables, automatic parsing at app startup
- **OAuth token encryption**: Google tokens (access/refresh/id) encrypted before MongoDB storage (DB breach protection)

**Guarantees**:
- Secrets never in plaintext but in environment variables (production)

### 5. Network Isolation and Contexts

**Benefit**: Limited blast radius in case of compromise, least privilege principle compliance.

**Implementation**:
- For**Azure Container Apps (Agenti, Auth Service, Reverse Proxy)**: Containers are deployed in an isolated managed environnement who is only accessible via a private endpoint
- **Functions**: AuthorizationLevel.Function (keys required), no AuthLevel.Anonymous - For functions, higher network isolation has to be carried by a NAT Gateway but is too costly at the moment.
- **Next.js Frontend**: Only component with direct public access But domain : ivaninho.pro (who is the only entry point) is hosted and proxied by Cloudflare Nameservers additionaly too a WAF. Then only Cloudflare IPs are allowed to access the Azure Webapp

**Guarantees**:
- Backend never directly exposed to internet
- Clear bounded context per component (auth ≠ business logic)
- Network policies applied at Vnet level

### 6. Observability and Telemetry

**Benefit**: Rapid incident detection, facilitated post-mortem, continuous performance metrics.

**Implementation**:
- **Application Insights**: Distributed traces, exceptions, performance metrics (auth-service, functions)
- **Winston structured logs**: JSON format, timestamp, level, service, environment, PII anonymization (masked emails)
- **Health checks**: `/health` endpoint on each service (nginx, auth-service, WebDB), 30s interval, 3 retries
- **Security disablements**: Auto-collect requests disabled (no Authorization header logs), Live Metrics off (cost)

**Guarantees**:
- Request correlation via traceId (distributed tracing)
- No PII in plaintext logs (GDPR compliance)
- Configurable alerts via Azure Monitor (CPU, latency, errors)

---

## Security & Trust

### AuthN/AuthZ Strategy

**Authentication**:
- NextAuth v5 (Auth.js) as central framework
- HMAC-SHA256 signed JWT (256-bit minimum secret from Key Vault)
- Extended claims validation: `iss`, `aud`, `nbf`, `exp`, `sub`, `alg: "none"` rejection
- Dual token (refresh HttpOnly cookie + access Bearer header)

**Authorization**:
- Tokens carry `userId`, `email`, `name`, `provider` (credentials/google)
- Validation at each protected endpoint (express middleware)

### Common Attack Protection

| Threat | Implemented Mitigation | Level |
|--------|------------------------|-------|
| **Credential Stuffing** | Turnstile + auth rate limit (30 req/min) + bcrypt slow hash | High |
| **Session Hijacking** | Short-lived access tokens (15 min) + refresh rotation + blacklist | High |
| **XSS** | HttpOnly cookies (refresh), strict Next.js CSP, input sanitization | High |
| **CSRF** | Double-submit cookie (global middleware), public endpoint exemptions | High |
| **SQL Injection** | MongoDB (NoSQL), strict type validation before queries | High |
| **JWT None Algorithm** | Explicit `alg: "none"` rejection in verification | High |
| **Timing Attacks** | bcrypt.compare always executed (dummy hash if user doesn't exist) | Medium |
| **Replay Attacks** | Unique OAuth state (10 min TTL), refresh token revoked after use | Medium |
| **DDoS** | Nginx rate limiting + Cloudflare layer 7 protection | Medium |
| **Secrets Leak** | Key Vault, no secrets in code/repos, log anonymization | High |

### Security Headers and Policies

**Next.js (Frontend)**:
- Content-Security-Policy: `script-src 'unsafe-inline'` (Next.js hydration), `connect-src` reverse proxy whitelist
- Strict-Transport-Security: max-age=1 year, includeSubDomains, preload
- X-Content-Type-Options: nosniff
- X-Frame-Options: DENY

**Nginx (Reverse Proxy)**:
- Access-Control-Allow-Origin: $cors_origin (explicit whitelist)
- Access-Control-Allow-Credentials: true (cross-origin cookies)
- Cache-Control: no-store on sensitive auth endpoints

**Auth Service (Helmet.js)**:
- CSP: `default-src 'self'`, `style-src 'unsafe-inline'`, `img-src data: https:`
- HSTS: maxAge 31536000, includeSubDomains, preload

## Scalability & Reliability

### Scaling Strategy

**Statelessness**:
- No sticky session required (JWT stateless for access tokens)
- Refresh tokens in database but sporadic requests (1x/day per user)
- Nginx can scale horizontally without inter-instance coordination

**Current resources**:
- Container Apps: 0.25 vCPU / 0.5 GiB RAM per instance (cost optimized)
- Horizontal scaling configured : Min 0 if at least 1 http request -> up to 1 and 2 max (Cost optimized)

**Assumption**: Current traffic < 100 concurrent users, no immediate aggressive scaling needed.

**Identified Contention Points**:
1. **MongoDB Atlas**: `revoked_tokens` collection queried at each auth request (performant index required)
2. **Key Vault**: Secrets fetched at startup only (not in hot path), cached in memory
3. **Turnstile validation**: External Cloudflare API call (5s timeout, retry possible)

### Resilience and Recovery

**Health Checks (While online)**:
- Frequency: 30s interval, 3 retries, 5s timeout
- Endpoints: `/health` returns uptime, version, DB status (optional)
- Action: Container Apps restarts instance if unhealthy 3x consecutive

**Configured Timeouts**:
- Nginx proxy_read_timeout: 30-60s depending on endpoint (auth vs business API)
- MongoDB client: connectTimeoutMS 10s, serverSelectionTimeoutMS 5s
- Turnstile validation: 5s HTTP timeout

**Retry Logic**:
- Present in code (`retry-helper.js` mentioned), implementation details not analyzed
- Recommendation: Exponential backoff with jitter, max 3 retries

## Operations & Observability

### Logs and Metrics

**Logging Levels**:
- **Debug**: Dev environment only, detailed OAuth flow traces
- **Info**: Production, major events (login success, token refresh)
- **Warn**: Suspicious requests (rate limit hit, CSRF fail)
- **Error**: Application exceptions, DB errors, timeouts

**PII Anonymization**:
- Emails: `j***@gmail.com` (central character masking)
- Authorization headers: `[REDACTED]` in nginx and Application Insights logs
- Cookies: `[REDACTED]` in structured logs

**Collected Metrics**:
- Application Insights: Request latency, dependencies (MongoDB, Key Vault), exception rate
- Nginx: Access logs (IP, user-agent, status code, latency), error logs
- MongoDB Atlas: Ops/sec, active connections, slow queries

---

## Delivery & Governance

### CI/CD Pipeline

**Platform**: GitHub Actions

**Workflow**:
1. Trigger: Push to `main` branch or manual dispatch
2. Runtime: ubuntu-latest, Node.js 22.x
3. Steps:
   - Checkout code
   - `npm ci` (clean dependency install)
   - `npm run build` (Next.js production build)
   - Clean devDependencies (reduce bundle)
   - Deploy via Azure Web App publish profile (`ivaninho-hub-main`)


### Environments

**Observed**:
- **Production**: Azure Switzerland North, domain `ivaninho.pro`
- **Development**: Local (Docker Compose, localhost:3000/3001/8080)


### Configuration and Secrets Management

**Production**:
- Secrets: Azure Key Vault (fetched at startup via Managed Identity)
- Environment variables: Container Apps / Function App Settings (non-sensitive: PORT, NODE_ENV, LOG_LEVEL)
- Application configuration: Hard-coded or env vars (no external config server like Azure App Configuration)

**Development**:
- `.env.local` (not committed, .gitignore)
- Docker Compose with variables injected from `.env.local`

### Tests and Code Quality

**Critical Gaps**:
- No automated tests found (unit, integration, E2E)
- No linting in pipeline (ESLint configured but non-blocking)
- No dependency security scan
- No measured code coverage

---

**Strengths**:
- Clear separation of responsibilities (bounded contexts)
- Modern stack (Next.js 14, NextAuth v5, Container Apps)
- Deep security (CSRF, XSS, JWT claims validation, Key Vault)
- Basic observability present (Application Insights, structured logs)

**Priority Improvement Areas**:
- Automated tests (critical gap, regression risk)
- Staging environment (secure deployments)
- WAF and configured scaling (resilience against attacks/spikes)
- Formalized circuit breakers and retry policies
